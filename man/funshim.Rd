% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/models.R
\name{funshim}
\alias{funshim}
\title{Fit Strong Heredity Interaction Model}
\usage{
funshim(x, y, e, df, group.penalty = c("gglasso", "MCP", "SCAD"),
  family = c("gaussian", "binomial"), weights, lambda.factor = ifelse(nobs <
  nvars, 0.01, 0.001), lambda.beta = NULL, lambda.gamma = NULL,
  nlambda.gamma = 10, nlambda.beta = 10, nlambda = 100, thresh = 0.001,
  maxit = 2000, initialization.type = c("ridge", "univariate"),
  center = TRUE, normalize = FALSE, verbose = TRUE, cores = 1)
}
\arguments{
\item{x}{Design matrix of dimension \code{n x q}, where \code{n} is the
number of subjects and q is the total number of variables; each row is an
observation vector. This must include all main effects and interactions as
well, with column names corresponding to the names of the main effects
(e.g. \code{x1, x2, E}) and their interactions (e.g. \code{x1:E, x2:E}).
All columns should be scaled to have mean 0 and variance 1; this is done
internally by the \code{\link{shim}} function.}

\item{y}{response variable. For \code{family="gaussian"} should be a 1 column
matrix or numeric vector. For \code{family="binomial"}, if the response is
a vector it can be numeric with 0 for failure and 1 for success, or a
factor with the first level representing "failure" and the second level
representing "success". Alternatively, For binomial logistic regression,
the response can be a matrix where the first column is the number of
"successes" and the second column is the number of "failures".}

\item{family}{response type. see \code{y} for details. Currently only
\code{family = "gaussian"} is implemented.}

\item{weights}{observation weights. Can be total counts if responses are
proportion matrices. Default is 1 for each observation. Currently NOT
IMPLEMENTED}

\item{lambda.factor}{The factor for getting the minimal lambda in lambda
sequence, where \code{min(lambda) = lambda.factor * max(lambda).
max(lambda)} is the smallest value of lambda for which all coefficients are
zero. The default depends on the relationship between \code{N} (the number
of rows in the matrix of predictors) and \code{p} (the number of
predictors). If \code{N > p}, the default is \code{1e-6}, close to zero. If
\code{N < p}, the default is \code{0.01}. A very small value of
lambda.factor will lead to a saturated fit.}

\item{lambda.beta}{sequence of tuning parameters for the main effects. If
\code{NULL} (default), this function will automatically calculate a
sequence using the \code{\link{shim_once}} function which will be over a
grid of tuning parameters for gamma as well. If the user specifies a
sequence then this function will not automatically perform the serach over
a grid. You will need to create the grid yourself e.g. repeat the
lambda.gamma for each value of lambda.beta}

\item{lambda.gamma}{sequence of tuning parameters for the interaction
effects. Default is \code{NULL} which means this function will
automatically calculate a sequence of tuning paramters. See
\code{\link{shim_once}} for details on how this sequence is calculated.}

\item{nlambda.gamma}{number of tuning parameters for gamma. This needs to be
specified even for user defined inputs}

\item{nlambda.beta}{number of tuning parameters for beta. This needs to be
specified even for user defined inputs}

\item{nlambda}{total number of tuning parameters. If \code{lambda.beta =
NULL} and \code{lambda.gamma = NULL} then \code{nlambda} should be equal to
\code{nlambda.beta x nlambda.gamma}. This is important to specify
especially when a user defined sequence of tuning parameters is set.}

\item{thresh}{Convergence thresh for coordinate descent. Each
coordinate-descent loop continues until the change in the objective
function after all coefficient updates is less than thresh. Default
value is \code{1e-4}.}

\item{maxit}{Maximum number of passes over the data for all tuning
parameter values; default is 100.}

\item{initialization.type}{The procedure used to estimate the regression
coefficients and used in the \code{\link{uni_fun}} function. If
\code{"univariate"} then a series of univariate regressions is performed
with the response variable \code{y}. If \code{"ridge"} then ridge
regression is performed using the \code{\link[glmnet]{cv.glmnet}} function
and the tuning parameter is chosen using 10 fold cross validation. The
default is \code{"ridge"}.}

\item{center}{Should \code{x} and \code{y} be centered. Default is
\code{TRUE}. Centering \code{y} applies to \code{family="gaussian"} only.}

\item{normalize}{Should \code{x} be scaled to have unit variance. Default is
\code{TRUE}}

\item{verbose}{Should iteration number and vector of length \code{nlambda} be
printed to console? Default is \code{TRUE}. 0 represents the algorithm has
not converged for the pair of tuning parameters lambda.beta and
lambda.gamma and 1 means it has converged}

\item{cores}{The number of cores to use for certain calculations in the
\code{\link{shim}} function, i.e. at most how many child processes will be
run simultaneously using the \code{parallel} package. Must be at least one,
and parallelization requires at least two cores. Default is 2.}

\item{main.effect.names}{character vector of main effects names. MUST be
ordered in the same way as the column names of \code{x}. e.g. if the column
names of \code{x} are \code{"x1","x2"} then \code{main.effect.names =
c("x1","x2")}}

\item{interaction.names}{character vector of interaction names. MUST be
separated by a colon (e.g. x1:x2), AND MUST be ordered in the same way as
the column names of \code{x}}
}
\value{
An object with S3 class "shim" \describe{ \item{b0}{Intercept
  sequence of length \code{nlambda}} \item{beta}{A nvars x \code{nlambda}
  matrix of main effects (\eqn{\beta}) coefficients, stored in sparse column
  format \code{("CsparseMatrix")}} \item{alpha}{A nvars x \code{nlambda}
  matrix of interaction effects (\eqn{\alpha}) coefficients, stored in sparse
  column format \code{("CsparseMatrix")}} \item{gamma}{A nvars x
  \code{nlambda} matrix of (\eqn{\gamma}) coefficients, stored in sparse
  column format \code{("CsparseMatrix")}} \item{lambda.beta}{The sequence of
  tuning parameters used for the main effects} \item{lambda.gamma}{The
  sequence of tuning parameters used for the interaction effects}
  \item{tuning.parameters}{2 x nlambda matrix of tuning parameters. The first
  row corresponds to \code{lambda.beta} and the second row corresponds to
  \code{lambda.gamma}} \item{dfbeta}{list of length \code{nlambda} where each
  element gives the index of the nonzero \eqn{\beta} coefficients}
  \item{dfalpha}{list of length \code{nlambda} where each element gives the
  index of the nonzero \eqn{\alpha} coefficients} \item{x}{x matrix }
  \item{y}{response data} \item{bx}{column means of x matrix} \item{by}{mean
  of response} \item{sx}{column standard deviations of x matrix}
  \item{call}{the call to the function} \item{nlambda.gamma}{nlambda.gamma}
  \item{nlambda.beta}{nlambda.beta} \item{nlambda}{nlambda}
  \item{interaction.names}{interaction names} \item{main.effect.names}{main
  effect names} }
}
\description{
function to fit the Strong Heredity Interaction Model for a
  sequence of tuning parameters. This is a penalized regression method that
  ensures the interaction term is non-zero only if its corresponding
  main-effects are non-zero.
}
\details{
the index of the tuning parameters is as follows. If for example
  there are 10 lambda_gammas, and 20 lambda_betas, then the first
  lambda_gamma gets repeated 20 times. So the first twenty entries of tuning
  parameters correspond to 1 lambda_gamma and the 20 lambda_betas
}
\note{
if the user specifies lambda.beta and lambda.gamma then they this will
  not take all possible combinations of lambda.beta and lambda.gamma. It will
  be the first element of each as a pair, and so on. This is done on purpose
  for use with the cv.shim function which uses the same lambda sequences for
  each fold.
}
\examples{
# number of observations
n <- 100

# number of predictors
p <- 5

# environment variable
e <- sample(c(0,1), n, replace = T)

# main effects
x <- cbind(matrix(rnorm(n*p), ncol = p), e)

# need to label columns
dimnames(x)[[2]] <- c("x1","x2","x3","x4","x5","e")

# design matrix without intercept (can be user defined interactions)
X <- model.matrix(~(x1+x2+x3)*e+x1*x4+x3*x5-1, data = as.data.frame(x))

# names must appear in the same order as X matrix
interaction_names <- grep(":", colnames(X), value = T)
main_effect_names <- setdiff(colnames(X), interaction_names)

# response
Y <- X \%*\% rbinom(ncol(X), 1, 0.6) + 3*rnorm(n)

# standardize data
data_std <- standardize(X,Y)

result <- shim(x = data_std$x, y = data_std$y,
            main.effect.names = main_effect_names,
            interaction.names = interaction_names)
}
\seealso{
\code{\link{shim_once}}
}
\author{
Sahir Bhatnagar

  Maintainer: Sahir Bhatnagar \email{sahir.bhatnagar@mail.mcgill.ca}
}
